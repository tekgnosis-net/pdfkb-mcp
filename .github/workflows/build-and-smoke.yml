name: Build and Smoke Test

on:
  workflow_dispatch: {}
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  build-and-smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Restore BuildKit cache
        uses: actions/cache@v4
        with:
          path: .buildx-cache
          key: buildx-cache-${{ runner.os }}-pyproject-${{ hashFiles('pyproject.toml') }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build container image (with BuildKit cache)
        uses: docker/build-push-action@v4
        with:
          context: .
          push: false
          tags: pdfkb-pr-smoke
          load: true
          cache-from: type=local,src=.buildx-cache
          cache-to: type=local,dest=.buildx-cache,mode=max
          build-args: |
            PDF_PARSER=docling

      - name: Save built image as tar (for debugging)
        run: |
          docker save pdfkb-pr-smoke -o pdfkb-pr-smoke-image.tar

      - name: Upload built image artifact
        uses: actions/upload-artifact@v4
        with:
          name: pdfkb-pr-smoke-image
          path: pdfkb-pr-smoke-image.tar

      - name: Start container (CPU embeddings)
        run: |
          docker run -d --name pdfkb-pr-smoke -p 9000:8000 \
            -e PDFKB_EMBEDDING_DEVICE=cpu \
            pdfkb-pr-smoke

      - name: Wait for /health (up to ~5 minutes with backoff)
        run: |
          set -euo pipefail
          max_attempts=120
          attempt=1
          sleep_seconds=1
          while [ $attempt -le $max_attempts ]; do
            status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9000/health || echo "")
            echo "Attempt $attempt: status=$status"
            if [ "$status" = "200" ]; then
              echo "health ok"
              break
            fi
            # Exponential-ish backoff with cap
            sleep $sleep_seconds
            attempt=$((attempt+1))
            if [ $sleep_seconds -lt 10 ]; then
              sleep_seconds=$((sleep_seconds*2))
            fi
          done
          if [ "$status" != "200" ]; then
            echo "Service did not become healthy in time"
            docker logs pdfkb-pr-smoke || true
            exit 1
          fi

      - name: Extra wait for background processing (30s)
        run: |
          # Allow the app a short time to process mounted/sample docs before running a sample search
          sleep 30

      - name: Run a basic API smoke (status)
        run: |
          curl -sS http://localhost:9000/api/status || true

      - name: Parser import checks (local built image)
        run: |
          set -euo pipefail
          chmod +x ./scripts/ci-parser-check.sh || true
          ./scripts/ci-parser-check.sh pdfkb-pr-smoke

      - name: Per-parser integration smoke (process sample PDF)
        run: |
          set -euo pipefail
          parsers=("docling" "marker" "mineru" "pymupdf4llm")
          SAMPLE=tests/sample.pdf
          if [ ! -f "$SAMPLE" ]; then
            echo "Sample PDF not found at $SAMPLE" >&2
            exit 1
          fi

          for p in "${parsers[@]}"; do
            echo "--- Testing parser: $p ---"
            # Ensure previous container is removed
            docker rm -f pdfkb-pr-smoke || true

            # Start container with parser selected
            docker run -d --name pdfkb-pr-smoke -p 9000:8000 \
              -e PDFKB_EMBEDDING_DEVICE=cpu -e PDFKB_PDF_PARSER="$p" \
              pdfkb-pr-smoke

            # Wait for /health (up to 2 minutes)
            max=60; i=0; ok=0
            while [ $i -lt $max ]; do
              status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9000/health || echo "")
              if [ "$status" = "200" ]; then ok=1; break; fi
              i=$((i+1)); sleep 2
            done
            if [ $ok -ne 1 ]; then
              echo "Container did not become healthy for parser $p" >&2
              docker logs pdfkb-pr-smoke || true
              docker rm -f pdfkb-pr-smoke || true
              exit 1
            fi

            # Copy sample PDF into container to trigger file monitor processing
            docker cp "$SAMPLE" pdfkb-pr-smoke:/app/documents/sample-${p}.pdf

            # Wait for processing log message (up to 2 minutes)
            found=0; attempts=0; max_attempts=60
            while [ $attempts -lt $max_attempts ]; do
              if docker logs --since 1s pdfkb-pr-smoke 2>&1 | egrep -i "Starting .* parsing|Processing PDF" >/dev/null 2>&1; then
                found=1; break
              fi
              attempts=$((attempts+1)); sleep 2
            done

            if [ $found -eq 1 ]; then
              echo "Parser $p processed sample (log found)"
            else
              echo "Parser $p did not process sample within timeout" >&2
              docker logs pdfkb-pr-smoke || true
              docker rm -f pdfkb-pr-smoke || true
              exit 1
            fi

            # Teardown for this parser
            docker rm -f pdfkb-pr-smoke || true
            sleep 1
          done

      - name: Run a sample search (best-effort)
        run: |
          set -euo pipefail
          # Try a search; return success even if results are empty, but capture output for debugging
          resp=$(curl -sS -X POST http://localhost:9000/api/search -H "Content-Type: application/json" -d '{"query":"test","limit":3}' || true)
          echo "Search response: $resp"


      - name: Teardown
        if: always()
        run: |
          docker rm -f pdfkb-pr-smoke || true
